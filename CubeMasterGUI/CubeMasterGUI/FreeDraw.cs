using System;
using System.Collections.Generic;
using System.Linq;
using System.Text;
using System.Windows.Forms;
using System.Drawing;

namespace CubeMasterGUI
{
    public class FreeDraw
    {
        /// <summary>
        /// The underlying Cube data structure, implemented via CubeController.DLL.
        /// </summary>
        private CubeController.Cube _cube;
        
        /// <summary>
        /// A buffer to store the user's Copied plane into. 
        /// </summary>
        private bool[][] _planeBuffer;

        /// <summary>
        /// A [Key, Value] lookup to translate a string to a CubeController.Cube.REFLECTION
        /// enumeration. 
        /// </summary>
        private Dictionary<String, CubeController.Cube.REFLECTION> _reflections;

        /// <summary>
        /// A [Key, Value] lookup to retreive the appropriate image for a button that
        /// represents a drawing function. 
        /// </summary>
        private Dictionary<Button, Tuple<Bitmap, Bitmap>> _drawingButtonImages;

        /// <summary>
        /// The currently selected axis of _cube. This will determine how the patterns
        /// and data transmitted to the underlying data structure are depicted in 3D space.
        /// </summary>
        public CubeController.Cube.AXIS SelectedAxis { get; set; }

        /// <summary>
        /// The reflection parameter of _cube. Determines which half of a cube (along
        /// a given axis of orientation) to set as the source of the CubeController.Cube.Symmetry()
        /// invocation. 
        /// </summary>
        public CubeController.Cube.REFLECTION Reflection { get; set; }

        /// <summary>
        /// The selected direction as to how 
        /// effects and advanced drawing functions are processed in 3D space. 
        /// </summary>
        public CubeController.Cube.DIRECTION Direction { get; set; }

        /// <summary>
        /// The currently selected plane. Tightly coupled this.SelectedAxis.
        /// </summary>
        public int SelectedPlane { get; set; }

        /// <summary>
        /// An enumeration of various drawing modes. 
        /// </summary>
        public enum DRAWING_MODE { SINGLE, LINE, RECTANGLE, CIRCLE };

        /// <summary>
        /// The currently selected DRAWING_MODE. 
        /// </summary>
        public DRAWING_MODE CurrentDrawingMode { get; set; }

        /// <summary>
        /// Creates an instance of the Free Draw Controller object. 
        /// </summary>
        /// <param name="cube">The cube data structure, generated by a parent controller.</param>
        public FreeDraw(ref CubeController.Cube cube)
        {
            _cube = cube;
            this.CurrentDrawingMode = DRAWING_MODE.SINGLE;
            this.Reflection = CubeController.Cube.REFLECTION.ORIGIN;

            _drawingButtonImages = new Dictionary<Button, Tuple<Bitmap, Bitmap>>();

            _reflections = new Dictionary<string, CubeController.Cube.REFLECTION>();
            _reflections.Add("origin", CubeController.Cube.REFLECTION.ORIGIN);
            _reflections.Add("terminus", CubeController.Cube.REFLECTION.TERMINUS);
        }

        /// <summary>
        /// Update the currently selected reflection parameter, based on the 
        /// passed reflection string. 
        /// </summary>
        /// <param name="refl"></param>
        public void SetReflection(string refl)
        {
            this.Reflection = _reflections[refl.ToLowerInvariant()];
        }

        /// <summary>
        /// Sets a voxel within _cube, by receiving the coordinates of a 2D Voxel element
        /// on screen. 
        /// </summary>
        /// <param name="grid_x"></param>
        /// <param name="grid_y"></param>
        public void SetVoxel(int grid_x, int grid_y)
        {
            // Translation from 2D Voxel Grid to 3D cube needs to be handled. 
            switch (this.SelectedAxis)
            {
                case CubeController.Cube.AXIS.AXIS_X:
                    _cube.SetVoxel(this.SelectedPlane, grid_x, grid_y);
                    break;
                case CubeController.Cube.AXIS.AXIS_Y:
                    _cube.SetVoxel(grid_x, this.SelectedPlane, grid_y);
                    break;
                case CubeController.Cube.AXIS.AXIS_Z:
                    _cube.SetVoxel(grid_y, grid_x, this.SelectedPlane);
                    break;
                default:
                    break;
            }
        }

        /// <summary>
        /// Sets a voxel within _cube based on three coordinate parameters.
        /// </summary>
        /// <param name="x">The x coordinate.</param>
        /// <param name="y">The y coordinate.</param>
        /// <param name="z">The z coordiante.</param>
        public void SetVoxel(int x, int y, int z)
        {
            _cube.SetVoxel(x, y, z);
        }

        /// <summary>
        /// Sets a voxel within _cube based on a CubeController.Point object. 
        /// </summary>
        /// <param name="p"></param>
        public void SetVoxel(CubeController.Point p)
        {
            _cube.SetVoxel(p.X, p.Y, p.Z);
        }

        /// <summary>
        /// Clears a voxel within _cube based on a the coordinates of a 2D Voxel element.
        /// </summary>
        /// <param name="grid_x"></param>
        /// <param name="grid_y"></param>
        public void ClearVoxel(int grid_x, int grid_y)
        {
            // Translation from a 2D Voxel element to 3D space must be handled. 
            switch (this.SelectedAxis)
            {
                case CubeController.Cube.AXIS.AXIS_X:
                    _cube.ClearVoxel(this.SelectedPlane, grid_x, grid_y);
                    break;
                case CubeController.Cube.AXIS.AXIS_Y:
                    _cube.ClearVoxel(grid_x, this.SelectedPlane, grid_y);
                    break;
                case CubeController.Cube.AXIS.AXIS_Z:
                    _cube.ClearVoxel(grid_y, grid_x, this.SelectedPlane);
                    break;
                default:
                    break;
            }
        }

        /// <summary>
        /// Clears a voxel within _cube based on three coordinate parameters.
        /// </summary>
        /// <param name="x">The x coordinate.</param>
        /// <param name="y">The y coordinate.</param>
        /// <param name="z">The z coordinate.</param>
        public void ClearVoxel(int x, int y, int z)
        {
            _cube.ClearVoxel(x, y, z);
        }

        /// <summary>
        /// Clears a voxel within _cube based on a CubeController.Point object.
        /// </summary>
        /// <param name="p"></param>
        public void ClearVoxel(CubeController.Point p)
        {
            _cube.ClearVoxel(p.X, p.Y, p.Z);
        }

        /// <summary>
        /// Swaps a voxel within _cube based on the coordinates of a 2D Voxel element.
        /// </summary>
        /// <param name="grid_x"></param>
        /// <param name="grid_y"></param>
        public void SwapVoxel(int grid_x, int grid_y)
        {
            switch (this.SelectedAxis)
            {
                case CubeController.Cube.AXIS.AXIS_X:
                    _cube.SwapVoxel(this.SelectedPlane, grid_x, grid_y);
                    break;
                case CubeController.Cube.AXIS.AXIS_Y:
                    _cube.SwapVoxel(grid_x, this.SelectedPlane, grid_y);
                    break;
                case CubeController.Cube.AXIS.AXIS_Z:
                    _cube.SwapVoxel(grid_y, grid_x, this.SelectedPlane);
                    break;
                default:
                    break;
            }
        }

        /// <summary>
        /// Swaps a voxel within _cube based on three coordinate parameters.
        /// </summary>
        /// <param name="x">The x coordinate.</param>
        /// <param name="y">The y coordinate.</param>
        /// <param name="z">The z coordinate.</param>
        public void SwapVoxel(int x, int y, int z)
        {
            _cube.SwapVoxel(x, y, z);
        }

        /// <summary>
        /// Swaps a voxel within _cube based on a CubeController.Point object.
        /// </summary>
        /// <param name="p"></param>
        public void SwapVoxel(CubeController.Point p)
        {
            _cube.SwapVoxel(p.X, p.Y, p.Z);
        }

        /// <summary>
        /// Clears every voxel on the currently selected plane on the selected
        /// axis. 
        /// </summary>
        public void ClearPlane()
        {
            _cube.ClearPlane(this.SelectedAxis, this.SelectedPlane);
        }

        /// <summary>
        /// Returns the currently selected plane on the selected axis as 
        /// a 2D array of booleans.
        /// </summary>
        /// <returns></returns>
        public bool[][] GetPlane()
        {
            return _cube.GetPlane(this.SelectedAxis, this.SelectedPlane);
        }

        /// <summary>
        /// Sets every voxel on the currently selected plane on the selected
        /// axis. 
        /// </summary>
        public void SetPlane()
        {
            _cube.SetPlane(this.SelectedAxis, this.SelectedPlane);
        }

        /// <summary>
        /// Clears every voxel on the cube.
        /// </summary>
        public void ClearEntireCube()
        {
            _cube.ClearEntireCube();
        }

        /// <summary>
        /// Begins a short demo. 
        /// </summary>
        public void Demo()
        {
            int i = 200;
            while (--i >= 0)
            {
                _cube.BoxWoopWoop(1, 200, true, 8);
                _cube.BoxWoopWoop(1, 200, false, 8);
            }

            i = 200;
            while (--i >= 0)
            {
                _cube.Firework(100, 5, 100);
            }

            i = 200;
            while (--i >= 0)
            {
                _cube.TelcStairs(true, 100);
            }

            i = 200;
            while (--i >= 0)
            {
                _cube.RandomSparkle(300, 5);
            }
        }

        /// <summary>
        /// Draws a line between the 3D voxel referenced by p1 and the 3D voxel
        /// referenced by p2. 
        /// </summary>
        /// <param name="p1">The voxel to begin drawing from.</param>
        /// <param name="p2">The voxel to draw to.</param>
        public void DrawLine(CubeController.Point p1, CubeController.Point p2)
        {
            _cube.DrawLine(p1, p2);
        }

        /// <summary>
        /// Draws a rectangle on the currently selected axis between the 3D
        /// voxel referenced by p1 and the 3D voxel referenced by p2. 
        /// </summary>
        /// <param name="p1">The upper-left corner of the rectangle.</param>
        /// <param name="p2">The lower-right corner of the rectangle.</param>
        public void DrawRectangle(CubeController.Point p1, CubeController.Point p2)
        {
            _cube.DrawRectangle(this.SelectedAxis, p1, p2);
        }

        /// <summary>
        /// Draws a circle around the 3D voxel referenced by p1 to a distance
        /// approximately equal to that of p2's distance to p1. 
        /// </summary>
        /// <param name="center">The center of the circle to draw around.</param>
        /// <param name="rad">A point at ~= 1 radius length from the center.</param>
        public void DrawCircle(CubeController.Point center, CubeController.Point rad)
        {
            _cube.DrawCircle(this.SelectedAxis, center, rad);
        }

        /// <summary>
        /// Translates a 2D voxel to a CubeController.Point. 
        /// </summary>
        /// <param name="vox">2D Voxel to translate.</param>
        /// <returns>vox's place in 3D space.</returns>
        public CubeController.Point VoxelToPoint(Voxel vox)
        {
            CubeController.Point point; 

            switch (this.SelectedAxis)
            {
                case CubeController.Cube.AXIS.AXIS_X:
                    point = new CubeController.Point(this.SelectedPlane, vox.X, vox.Y);
                    break;
                case CubeController.Cube.AXIS.AXIS_Y:
                    point = new CubeController.Point(vox.X, this.SelectedPlane, vox.Y);
                    break;
                case CubeController.Cube.AXIS.AXIS_Z:
                    point = new CubeController.Point(vox.Y, vox.X, this.SelectedPlane);
                    break;
                default:
                    point = null;
                    break;
            }

            return point;
        }

        /// <summary>
        /// Rotate the currently selected plane and axis by degree theta.
        /// </summary>
        /// <param name="theta">Angle of rotation.</param>
        public void Rotate(int theta)
        {
            _cube.RotatePlane(this.SelectedAxis, this.SelectedPlane, theta);
        }

        /// <summary>
        /// Allows a user to copy their selected plane and axis 
        /// to a plane buffer (later used for Pasting).
        /// </summary>
        public void CopyPlane()
        {
            _planeBuffer = _cube.GetPlane(this.SelectedAxis, this.SelectedPlane);
        }
        
        /// <summary>
        /// Allows a user to paste a previously copied plane from a plane buffer to 
        /// the desired cube plane and axis. 
        /// </summary>
        public void PastePlane()
        {
            if (_planeBuffer != null)
            {
                _cube.PatternSetPlane(this.SelectedAxis, this.SelectedPlane, _planeBuffer);
            }
        }

        /// <summary>
        /// Creates symmetry along the X axis, sourcing data based on this.Reflection.
        /// </summary>
        public void SymmetryX()
        {
            _cube.SymmetryAlongAxis(CubeController.Cube.AXIS.AXIS_X, this.Reflection);
        }

        /// <summary>
        /// Creates symmetry along the Y axis, sourcing data based on this.Reflection.
        /// </summary>
        public void SymmetryY()
        {
            _cube.SymmetryAlongAxis(CubeController.Cube.AXIS.AXIS_Y, this.Reflection);
        }

        /// <summary>
        /// Creates symmetry along the Z axis, sourcing data based on this.Reflection.
        /// </summary>
        public void SymmetryZ()
        {
            _cube.SymmetryAlongAxis(CubeController.Cube.AXIS.AXIS_Z, this.Reflection);
        }

        /// <summary>
        /// Shifts all planes "UP" along the selected axis. 
        /// </summary>
        public void ShiftUp()
        {
            this.Direction = CubeController.Cube.DIRECTION.FORWARD;
            _cube.ShiftAndRoll(this.SelectedAxis, this.Direction);
        }

        /// <summary>
        /// Shifts all planes "DOWN" along the selected axis.
        /// </summary>
        public void ShiftDown()
        {
            this.Direction = CubeController.Cube.DIRECTION.REVERSE;
            _cube.ShiftAndRoll(this.SelectedAxis, this.Direction);
        }

        /// <summary>
        /// Returns the appropriate image for a button. 
        /// </summary>
        /// <param name="btn">The button to lookup images for.</param>
        /// <param name="alt">Do we need the alternate image?</param>
        /// <returns>Bitmap representing the appropriate image.</returns>
        public Bitmap GetDrawingFunctionImg(Button btn, bool alt)
        {
            return alt ? _drawingButtonImages[btn].Item2 : _drawingButtonImages[btn].Item1;
        }

        /// <summary>
        /// Alternates the drawing image of a given button, based on whether we
        /// need the primary or alternate image.
        /// </summary>
        /// <param name="toSwap">The button to swamp an image for.</param>
        /// <param name="alt">Do we need the alternate image?</param>
        public void SwapDrawingFunctionImg(Button toSwap, bool alt)
        {
            toSwap.Image = alt ? _drawingButtonImages[toSwap].Item2 : _drawingButtonImages[toSwap].Item1;
        }

        /// <summary>
        /// Add a button and its two button icon images to a lookup table.
        /// </summary>
        /// <param name="btn">The button to add as a key.</param>
        /// <param name="path1">Primary button icon.</param>
        /// <param name="path2">Alternate button icon.</param>
        public void AddDrawingImagesEntry(Button btn, string path1, string path2)
        {
            _drawingButtonImages.Add(btn, new Tuple<Bitmap, Bitmap>(new Bitmap(path1), new Bitmap(path2)));
        }
    }
}
